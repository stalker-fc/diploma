\subsection{\large{Развертывание приложения}}
\addcontentsline{toc}{subsection}

Помимо программной реализации необходимо уделить внимание вопросам развертывания приложения.
Данный этап можно разбить на 3 части: сборка, развертывание, маршрутизация.

\subsubsection{\large{Docker}}
\addcontentsline{toc}{subsubsection}

Для развертывания приложений используется docker-compose.
Данная утилита в качестве своих составных блоков используют Docker-контейнеры.

Для того чтобы запустить Docker-контейнер, требуется Docker-образ, на основе которого данный контейнер и будет
запущен.
Чтобы получить любой Docker-образ, его необходимо собрать. В Dockerfile лежат команды сборки


\begin{itemize}
    \item Занимали меньший объем памяти
    \item Были защищены
    \item Собирались как
\end{itemize}

Воспользуйтесь многоэтапными сборками для того, чтобы создавать более компактные и лучше защищённые образы Docker.
Многоэтапные сборки Docker позволяют разделять выполнение действий, описываемых в файлах Dockerfile, на несколько этапов. Например, можно выделить этап компиляции и сборки приложения, а тем, что получится после прохождения этого этапа, можно воспользоваться на следующих этапах. Так как для создания образа используется лишь один, финальный этап, зависимости и инструменты, связанные с подготовкой приложения к работе, в итоговый образ не входят, что позволяет выйти на компактный, модульный образ, готовый к использованию в продакшне.
Вот пример файла Dockerfile из сферы веб-разработки:

\noindent \textbf{Зависимости при сборке}
Для работы `Python`-приложения требуется установка зависимостей.
Так как у нас используется

После сборки Docker-образа возможны 3 сценария использования:
\begin{itemize}
    \item Приложение
    \item Библиотека с исходным кодом
    \item Образ для запуска тестов
\end{itemize}

Каждый докер образ должен использоваться для закрытия какой-то цели. Концептуально, их две:
- какой-то артефакт: библиотека или приложение
- образ для запуска тестов

В финальном образе, который генерирует артефакт, не должно быть зависимостей для запуска тестов,
а также самих тестов.
Для того, чтобы можно было использовать docker имеет ключевое слово `target`, чтобы можно было собирать один
и тот же Dockerfile под разные задачи. Для примера приведу Dockerfile.targets.

ARG APP\_ENV=development содержит тестовые зависимости, чтобы разработчик не пересобирал образ, когда запускает тесты
в IDE.

ARG APP\_ENV=production не содержит никаких лишних зависимостей

Docker-образы помимо развертывания на сервере используются еще и для отладки разработчиком.



\subsubsection{{Gitlab CI/CD}}
\addcontentsline{toc}{subsubsection}

Инструментом для выполнения операций CI/CD в компании является Gitlab CI/CD.
Данный инструмент предоставляет очень большой набор возможностей для развертывания приложения.

Система представляет монорепозиторий, в котором находится исходный код всех микросервисов.
Это сделано с целью повышения прозрачности логики развертывания.






Правила развертывания в Gitlab CI/CD представляют собой Directed Acyclic Graph(DAG).

Главным объектом в системе Gitlab CI/CD является Pipeline.
Pipeline выполняется



Он состоит их следующих частей:
- Pipeline
- Stage
- Job

DAG

\paragraph{Структура файлов CI/CD}

Все правила развертывания и сборки описываются в файле .gitlab-ci.yml,
его название и местоположение может быть изменено на любое другое в настройках репозитория.

Сложную конфигурацию CI/CD можно разбить на несколько разных логических компонент, поместив каждую из них
в отдельный файл. С целью упрощения поддержки и добавления новых правил развертывания предлагается следующая структура файлов.

\dirtree{%
.1 gitlab-ci.
.2 stage1.
.3 services.
.4 service1.yml.
.4 service2.yml.
.4 service3.yml.
.3 main.yml.
.2 stage2.
.3 services.
.4 service1.yml.
.4 service3.yml.
.4 service7.yml.
.3 main.yml.
.2 stage3.
.3 services.
.4 service2.yml.
.4 service3.yml.
.3 main.yml.
.1 main.yml.
}

Данная структура является иерархической.
Корневая директория называется \textbf{gitlab-ci}. В корневой директории находится файл \textbf{gitlab-ci/main.yml}
(см. пример кода на ),
внутри которого содержатся на верхнеуровневые файлы для каждого \textit{Stage}.
В директории каждого \textit{Stage} находится файл \textbf{main.yml} (см. пример кода)
который содержит включения на файлы
с описанием конфигурации для отдельного сервиса на этом этапе.

\lstinputlisting[caption={Пример кода \textbf{gitlab-ci/main.yml}},captionpos=b]{implementation/listings/deployment/main.yml}
\vskip 5mm

\lstinputlisting[caption={Пример кода \textbf{gitlab-ci/stage/main.yml}},captionpos=b]
{implementation/listings/deployment/main_stage.yml}
\vskip 5mm

\subsubsection{{Маршрутизация}}
\addcontentsline{toc}{subsubsection}

Есть несколько способов решения в

Но kubernetes является стрельбой из пушки по воробьям.
Он громоздкий, требует дополнительной квалификации персонала и обучения, в силу высокой сложности его инфраструктуры.
Так как у нас всего один вычислительный сервер, то использовать подобные конструкции не имеет никакого смысла.


Воспользуемся минимальными средствами, а именно комбинацией nginx

Все это выглядит следующим образом
* Здесь диаграмма `Global Plan Design Router` -> `Environment Plan Design Router` -> `Environment Services`

При развертывании нового окружения мы добавляем новое правило роутинга в Global Plan Design Router.
А при убивании окружения мы удаляем это правило.


\begin{itemize}
    \item Управление зависимостями
    \item Feature Testing
    \item nginx
    \item Структура файлов Gitlab-CI
    \item Окружения Gitlab-CI
    \item Сокращение времени сборки
\end{itemize}
